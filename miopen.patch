diff --git a/src/hip/handlehip.cpp b/src/hip/handlehip.cpp
index 0d5fef89..578db270 100644
--- a/src/hip/handlehip.cpp
+++ b/src/hip/handlehip.cpp
@@ -39,6 +39,9 @@
 #include <chrono>
 #include <thread>
 
+/* if defined, use hipMalloc/Memcpy/Free, else unified address space */
+//#define DGPU
+
 namespace miopen {
 
 // Get current context
@@ -64,21 +67,37 @@ std::size_t GetAvailableMemory()
 
 void* default_allocator(void*, size_t sz)
 {
+    void* result;
+#ifdef DGPU
     if(sz > GetAvailableMemory())
         MIOPEN_THROW("Memory not available to allocate buffer: " + std::to_string(sz));
-    void* result;
     auto status = hipMalloc(&result, sz);
     if(status != hipSuccess)
     {
         status = hipHostMalloc(&result, sz);
         if(status != hipSuccess)
             MIOPEN_THROW_HIP_STATUS(status,
                                     "Hip error creating buffer " + std::to_string(sz) + ": ");
     }
+#else // APU
+    if (posix_memalign(&result, 64, sz)) {
+        MIOPEN_THROW("Error: posix_memalign failed creating buffer " + std::to_string(sz) + ": ");
+        free(result);
+        exit(-1);
+    }
+#endif // #ifdef DGPU
     return result;
 }
 
-void default_deallocator(void*, void* mem) { hipFree(mem); }
+void default_deallocator(void*, void* mem) {
+#ifdef DGPU
+    hipFree(mem);
+#else // APU
+    if (mem) {
+        free(mem);
+    }
+#endif // #ifdef DGPU
+}
 
 int get_device_id() // Get random device
 {
@@ -220,25 +243,49 @@ Allocator::ManageDataPtr&
 Handle::WriteTo(const void* data, Allocator::ManageDataPtr& ddata, std::size_t sz)
 {
     this->Finish();
+#ifdef DGPU
     auto status = hipMemcpy(ddata.get(), data, sz, hipMemcpyHostToDevice);
     if(status != hipSuccess)
         MIOPEN_THROW_HIP_STATUS(status, "Hip error writing to buffer: ");
+#else // APU
+    void * retPtr = memcpy(ddata.get(), data, sz);
+    if (retPtr == nullptr)
+    {
+        MIOPEN_THROW("Error writing to buffer: ");
+    }
+#endif // #ifdef DGPU
     return ddata;
 }
 void Handle::ReadTo(void* data, const Allocator::ManageDataPtr& ddata, std::size_t sz)
 {
     this->Finish();
+#ifdef DGPU
     auto status = hipMemcpy(data, ddata.get(), sz, hipMemcpyDeviceToHost);
     if(status != hipSuccess)
         MIOPEN_THROW_HIP_STATUS(status, "Hip error reading from buffer: ");
+#else // APU
+    void * retPtr = memcpy(data, ddata.get(), sz);
+    if (retPtr == nullptr)
+    {
+        MIOPEN_THROW("Error reading from buffer: ");
+    }
+#endif // #ifdef DGPU
 }
 
 void Handle::Copy(ConstData_t src, Data_t dest, std::size_t size)
 {
     this->impl->set_ctx();
+#ifdef DGPU
     auto status = hipMemcpy(dest, src, size, hipMemcpyDeviceToDevice);
     if(status != hipSuccess)
         MIOPEN_THROW_HIP_STATUS(status, "Hip error copying buffer: ");
+#else // APU
+    void * retPtr = memcpy(dest, src, size);
+    if (retPtr == nullptr)
+    {
+        MIOPEN_THROW("Error copying buffer: ");
+    }
+#endif // #ifdef DGPU
 }
 
 KernelInvoke Handle::GetKernel(const std::string& algorithm,
diff --git a/src/kernels/conv3x3.s b/src/kernels/conv3x3.s
index b00dfb9d..260dd79c 100644
--- a/src/kernels/conv3x3.s
+++ b/src/kernels/conv3x3.s
@@ -25,7 +25,8 @@
  *******************************************************************************/
 
 .hsa_code_object_version 2,1
-.hsa_code_object_isa 8, 0, 3, "AMD", "AMDGPU"
+//.hsa_code_object_isa 8, 0, 3, "AMD", "AMDGPU"
+.hsa_code_object_isa 8, 0, 1, "AMD", "AMDGPU"
 
 .text
 .globl gcnAsmConv3x3U
diff --git a/src/tmp_dir.cpp b/src/tmp_dir.cpp
index ac27c782..e417d832 100644
--- a/src/tmp_dir.cpp
+++ b/src/tmp_dir.cpp
@@ -7,6 +7,7 @@ namespace miopen {
 void SystemCmd(std::string cmd)
 {
 // std::cout << cmd << std::endl;
+    std::cout << cmd << std::endl; // ** TEMP: DEBUG ONLY
 // We shouldn't call system commands
 #ifdef MIOPEN_USE_CLANG_TIDY
     (void)cmd;
